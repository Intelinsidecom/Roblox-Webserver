3D Avatar Thumbnail Pipeline - API and Data Flow Spec\n=======================================================\n\nContext\n-------\nThis document describes how the legacy web client expects the 3D avatar thumbnail system to behave, based on the existing JavaScript in:\n\n- /wwwroot/JS/Thumbnails/ThumbnailView.js\n- /wwwroot/JS/extensions/ThreeDeeThumbnails.js\n- /wwwroot/JS/3D/OBJMTLLoader.js\n- /wwwroot/JS/3D/MTLLoader.js\n\nIt is meant as a backend contract specification so server-side endpoints can be implemented to satisfy the client without needing to re-read the JS each time.\n\nHigh-Level Flow\n--------------\n1. Character.aspx renders an avatar thumbnail container:\n   - .thumbnail-holder element with:\n     - data-reset-enabled-every-page\n     - data-3d-thumbs-enabled="true"\n     - data-url="/thumbnail/user-avatar?userId={userId}&thumbnailFormatId=124&width=277&height=277"\n   - Inside it, a .thumbnail-span element with:\n     - data-3d-url="/avatar-thumbnail-3d/user-avatar?userId={userId}&width=277&height=277"\n     - (optionally) data-js-files with comma-separated URLs to three.js, tween.js, etc.\n\n2. On page ready, Roblox.ThumbnailView initializes:\n   - Finds .thumbnail-holder and its parent container.\n   - Calls p(), which decides whether to use 2D or 3D based on:\n     - WebGL support, localStorage flag, and data-3d-thumbs-enabled.\n   - p() calls either:\n     - y() to enable 3D, or\n     - f() to show standard 2D image.\n   - v() sets up the 2D/3D toggle button (.enable-three-dee).\n   - r flag is set so reloadThumbnail() can later reload the holder HTML and re-run p().\n\n3. When the user clicks the 2D/3D button:\n   - The label toggles between "2D" and "3D".\n   - y() is called when enabling 3D.\n   - y() calls t.load3DThumbnail(...) on the .thumbnail-span element, where t is $.fn.load3DThumbnail from ThreeDeeThumbnails.js.\n\n4. load3DThumbnail does two main things:\n   - Optionally loads 3D-related JS files (three.js, tween.js, controls, loaders).\n   - Starts a polling AJAX request to /avatar-thumbnail-3d/user-avatar?userId=... to obtain a URL pointing to OBJ/MTL metadata.\n\n5. Once the OBJ/MTL metadata is obtained, the client:\n   - Uses OBJMTLLoader and MTLLoader to fetch OBJ, MTL, and textures.\n   - Renders them in a Three.js WebGL canvas in place of the 2D <img>.\n\nFrontend Contracts in Detail\n----------------------------\n\n1. ThumbnailView.js contract\n----------------------------\nFile: /wwwroot/JS/Thumbnails/ThumbnailView.js\n\nImportant pieces:\n- i = ".thumbnail-holder"\n- o = ".thumbnail-span"\n- u = "RobloxUse3DThumbnailsV2" (localStorage key).\n\nInitialization (p function):\n- If WebGL is supported, 3D is enabled, and localStorage flag is true, p() calls:\n  - y():\n    - Hides the <img> inside .thumbnail-span.\n    - Calls t.load3DThumbnail(successCallback, failureCallback) on .thumbnail-span.\n  - v(): sets up the button.\n\nSuccess path from y():\n- t.load3DThumbnail(fnOnModelReady, fnOnError) eventually calls fnOnModelReady(canvasElement):\n  - ThumbnailView removes any other canvas elements under the parent container.\n  - 3D canvas remains.\n\nFailure path from y():\n- If load3DThumbnail reports failure, ThumbnailView calls d() and f():\n  - d(): add .disabled to the enable-three-dee button.\n  - f(): restores the <img> and triggers any [data-retry-url] thumbnail loading.\n\n2. ThreeDeeThumbnails.js contract\n---------------------------------\nFile: /wwwroot/JS/extensions/ThreeDeeThumbnails.js\n\nKey public API:\n- $.fn.load3DThumbnail(successCallback, errorCallback)\n\nExpected data attributes on the jQuery element (the .thumbnail-span):\n- data-3d-url: base URL to poll for 3D avatar metadata. Example:\n  - /avatar-thumbnail-3d/user-avatar?userId=1&width=277&height=277\n- data-js-files (optional after our patch): comma-separated list of JS files. Example:\n  - /JS/3D/three.js,/JS/3D/tween.js,/JS/3D/RobloxOrbitControls.js,/JS/3D/OBJMTLLoader.js,/JS/3D/MTLLoader.js\n\nBehavior:\n1) Dynamic script loading (l function):\n   - Input: callback n, string r from data-js-files.\n   - If scripts were already loaded (internal flag i == true) OR r is null/empty:\n     - Calls n() immediately.\n   - Else:\n     - Splits r by comma to get URLs.\n     - Loads each via $.ajax({dataType:"script", url: <file>}), chained.\n     - After the last script, sets i = true and then calls n().\n\n2) Polling 3D avatar metadata (v function):\n   - Signature: v(n, t, r)\n     - n: base URL (data-3d-url) to poll, e.g. /avatar-thumbnail-3d/user-avatar?userId=1&width=277&height=277\n     - t: success handler; expects a JSON object with {obj, mtl, ...}.\n     - r: retry counter (internal).\n\n   - Behavior:\n     - Calls $.ajax({\n         url: n + "&_=" + $.now(),\n         method: "GET",\n         crossDomain: true,\n         xhrFields: { withCredentials: true },\n         cache: false\n       }).success(function(u) { ... });\n\n   - The response `u` is expected to be JSON with at least:\n     - u.Final : boolean\n     - u.Url   : string (URL to the OBJ/MTL metadata JSON)\n\n   - If u.Final is true:\n     - Calls $.getJSON(u.Url, function(n) { t(n) ... })\n     - So the URL u.Url must return JSON containing fields expected by `t` (see below).\n   - If u.Final is false and r < s (where s = 10) and `c` (cancel flag) is false:\n     - Schedules another poll after h ms (h = 2000), via setTimeout(v(...), h).\n\n3) Rendering using OBJMTLLoader (p function):\n   - Signature: p(objHashOrUrl, mtlHashOrUrl, $holder, metadataJson, onCanvasReady)\n   - Internals:\n     - Uses Three.js to create:\n       - a PerspectiveCamera\n       - a Scene\n       - OrbitControls\n     - Defines `tt = "/thumbnail/resolve-hash/"` as the base endpoint for loading raw OBJ/MTL data.\n     - Constructs a THREE.OBJMTLLoader and calls:\n       - it.load(tt, objHashOrUrl, mtlHashOrUrl, k, undefined, errorCallback)\n\n   - `objHashOrUrl` and `mtlHashOrUrl` come from the metadata JSON passed as `n` in load3DThumbnail:\n     - That JSON must contain at least:\n       - n.obj : string\n       - n.mtl : string\n\n   - on successful load of geometry/materials, the canvas gets appended into the thumbnail holder and passed to the success callback given to load3DThumbnail (the one ThumbnailView.js provides).\n\n3. OBJMTLLoader.js contract\n---------------------------\nFile: /wwwroot/JS/3D/OBJMTLLoader.js\n\nKey behaviors:\n- THREE.OBJMTLLoader.prototype.getHashUrl(hash):\n  - Accepts a 32-char hash.\n  - Computes an index to choose a texture CDN subdomain (t0-t7).\n  - Returns: "https://t<idx>.rbxcdn.com/" + hash\n\n- interpretData(loaderInstance, token, callback):\n  - token (`t` arg) can be:\n    1. A 32-character hash with no "/":\n       - Treated as hash; uses getHashUrl(hash), loads content via FileLoader, then calls callback(loaderInstance, fileContents).\n    2. A direct URL containing "/" and no newline:\n       - Loaded directly via FileLoader.\n    3. Otherwise, used as literal content.\n\n- load(n, t, i):\n  - Internally calls interpretData twice:\n    - First with `t` (MTL token) to obtain MTL data.\n    - Then with `n` (OBJ token) to obtain OBJ data.\n  - Parses MTL data with THREE.MTLLoader.\n  - Parses OBJ data with its own parse() into geometry.\n  - Binds materials from MTL into meshes.\n  - Finally invokes the callback `i(object3D, materialsCreator)`.\n\nImportant consequence:\n- The OBJ and MTL identifiers provided by the backend (metadata JSON fields `obj` and `mtl`) can be either:\n  - 32-character content hashes (preferred / legacy form), or\n  - Full absolute URLs to OBJ/MTL files, or\n  - Literal OBJ/MTL content strings.\n\n- Because ThreeDeeThumbnails.js calls:\n  - it.load(tt, t, r, ...) where `tt = "/thumbnail/resolve-hash/"`\n\n  The backend is expected to implement /thumbnail/resolve-hash/ such that:\n  - When passed some combination of arguments, the loader can derive the correct OBJ and MTL data.\n  - The exact argument wiring is a legacy detail; practically, our metadata JSON can directly supply OBJ and MTL URLs/hashes that resolve via that endpoint.\n\n4. MTLLoader.js contract\n------------------------\nFile: /wwwroot/JS/3D/MTLLoader.js\n\nThis loader is responsible for parsing .mtl content and loading textures referenced by the material.\n\nKey points:\n- It also has getHashUrl(hash) and uses https://t<idx>.rbxcdn.com/<hash> for texture maps referenced in the MTL.\n- MaterialCreator.createMaterial_ supports:\n  - kd, ka, ks (colors)\n  - map_Kd (diffuse texture map via getHashUrl)\n  - Ns (shininess), d (alpha).\n- loadTexture() handles retries and ensures textures are power-of-two sized for WebGL.\n\nBackend Endpoints Expected\n--------------------------\nBased on the above, the browser expects at least two backend endpoints to exist:\n\n1) /avatar-thumbnail-3d/user-avatar\n-----------------------------------\nPurpose:\n- Entry point for 3D avatar loading.\n- Returns a JSON object describing where to obtain OBJ/MTL metadata for a specific user and size.\n\nRequest:\n- Method: GET\n- URL (example):\n  - /avatar-thumbnail-3d/user-avatar?userId=1&width=277&height=277\n- Query parameters:\n  - userId : long (required)\n  - width  : int (used to choose appropriate render resolution)\n  - height : int (used to choose appropriate render resolution)\n\nResponse contract:\n- Content-Type: application/json\n- Body: JSON with at least:\n  - Final : boolean\n  - Url   : string\n\nMeaning:\n- Final == false:\n  - The avatar 3D data is not ready yet.\n  - The client will poll again (up to 10 times, every ~2 seconds) by calling the same URL with a cache-busting "_" parameter.\n- Final == true:\n  - The 3D data is ready.\n  - Url is an absolute or relative URL that returns the OBJ/MTL metadata JSON when requested via GET.\n\nExample minimal response (no polling):\n- HTTP 200\n- Body:\n  {\n    "Final": true,\n    "Url": "/avatar-thumbnail-3d/metadata/user/1/277x277"\n  }\n\n2) OBJ/MTL metadata endpoint (Url from above)\n--------------------------------------------\nPurpose:\n- To provide the client with simple JSON describing which OBJ and MTL identifiers to load.\n\nRequest:\n- Method: GET\n- URL: whatever is in the `Url` field from /avatar-thumbnail-3d/user-avatar.\n- No query params required by the client; they are implementation-defined.\n\nResponse contract:\n- Content-Type: application/json\n- Body: JSON with at least:\n  - obj : string\n  - mtl : string\n  - (optional) any additional fields you want; the current JS only uses obj and mtl.\n\nSemantics of obj and mtl:\n- The values can be:\n  - 32-character hashes that should be resolved through the /thumbnail/resolve-hash/ endpoint, or\n  - Full URLs to OBJ/MTL files, or\n  - Literal OBJ/MTL content.\n\nExample minimal response using hashes:\n- Body:\n  {\n    "obj": "0123456789abcdef0123456789abcdef",\n    "mtl": "fedcba9876543210fedcba9876543210"\n  }\n\nExample minimal response using absolute URLs:\n- Body:\n  {\n    "obj": "https://cdn.example.com/avatars/user1_277x277.obj",\n    "mtl": "https://cdn.example.com/avatars/user1_277x277.mtl"\n  }\n\n3) /thumbnail/resolve-hash/\n---------------------------\nPurpose:\n- Legacy endpoint used by OBJMTLLoader to resolve content hashes or short tokens into actual OBJ/MTL data.\n\nUsage in JS:\n- ThreeDeeThumbnails sets:\n  - var tt = "/thumbnail/resolve-hash/";\n  - it.load(tt, t, r, ...) where `t` and `r` are the obj and mtl fields from the metadata JSON.\n\nExpectations:\n- The exact historic contract is flexible, but in practice you can implement either of these models:\n\nModel A: Hash-based resolution (closest to legacy):\n- /thumbnail/resolve-hash/ behaves like a resource root.\n- OBJMTLLoader constructs final URLs by calling getHashUrl(hash) if token looks like a 32-char hash.\n- In that case, /thumbnail/resolve-hash/ may only be used as a placeholder and not need to respond to HTTP requests directly (if you always use CDN URLs in metadata).\n\nModel B: Direct URL model (simplest to implement):\n- Your metadata JSON returns absolute URLs for obj and mtl (no 32-char hashes).\n- OBJMTLLoader detects the tokens contain "/" and treats them as full URLs, bypassing getHashUrl and /thumbnail/resolve-hash/ entirely.\n- In this scenario, /thumbnail/resolve-hash/ does not need to be implemented at all to get basic 3D working.\n\nRecommended Minimal Implementation Strategy\n-----------------------------------------\nTo get 3D working with the smallest amount of backend code and complexity, you can do the following:\n\n1) Implement /avatar-thumbnail-3d/user-avatar as a controller action that:\n   - Validates userId and checks that the user exists.\n   - Immediately returns Final = true for now (no polling), with Url pointing at an internal metadata route.\n\n   Example (pseudo-C#):\n   return Ok(new { Final = true, Url = $"/avatar-thumbnail-3d/metadata/user/{userId}/{width}x{height}" });\n\n2) Implement GET /avatar-thumbnail-3d/metadata/user/{userId}/{size} that:\n   - Returns static or simple OBJ/MTL URLs for now (e.g., a generic placeholder model).\n   - Example JSON:\n     {\n       "obj": "/3d/placeholders/avatar_generic.obj",\n       "mtl": "/3d/placeholders/avatar_generic.mtl"\n     }\n\n3) Place a simple OBJ/MTL pair under wwwroot (e.g., /wwwroot/3d/placeholders/).\n   - They can be a very simple cube or placeholder mesh just to validate the pipeline.\n\n4) Skip implementing /thumbnail/resolve-hash/ initially by using absolute URLs in metadata, or implement a trivial passthrough if you want to stay closer to legacy behavior later.\n\nNotes on Security and Performance\n--------------------------------\n- These 3D endpoints can be CPU-expensive if they trigger full avatar-to-OBJ baking. In this repo, no baking implementation exists yet, so start with static placeholders.\n- Make sure any eventual dynamic OBJ/MTL generation is cached, and consider returning Final=false while baking is in progress if you add asynchronous generation later.\n- All endpoints should validate userId and respond with 404/400 as appropriate if the user does not exist or the request is malformed.\n
